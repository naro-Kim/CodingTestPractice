'''
[문제풀기 전 알아야할 Knapsack Problem]
배낭에 채울 물건을 자를 수 있다고 가정하는 'Fractional Knapsack'과 자를 수 없다 가정하는 '0-1 knapsack'문제가 있다.
알고리즘에 대한 이해가 없이 접근한다면, 두가지 방법으로 생각해볼 수 있을 것이다.

1. 가능한 경우의수를 모두 찾는 방법 Brute-Force
* n개의 물건이 있다하면, n개의 보석으로 만들 수 있는 부분집합 (power set)의 수는 2^n개이다. 
따라서 최악의 경우, 2^n 집합까지 탐색해야하므로 O(2^n)이 된다.

2. 가치가 높게 배정된 물건을 먼저 골라넣는 Greedy
* '무게당 가격'등, 주어진 정보에서 특정 기준을 정해놓고 기준 값이 가장 최대가 되도록 아이템을 선택한다.

이런 문제들로, 0-1배낭 문제에는 Brute-Force와 Greedy를 사용하지 않는다.
그대신, DP 알고리즘을 사용해 문제에 접근한다. DP를 사용할 땐, '최적의 원리'가 성립하는지 확인한다.
어떤 문제의 최적해는 부분 사례에대한 최적해를 항상 포함하며 그 문제에 대해 최적 원리가 성립한다. 

[문제 접근 방식] 
DP배열에 배낭 무게별로 최대로 담을 수 있는 가치를 기록한다. 
** 따라서, n개의 물건이 주어졌다고 했을 때 dp[n][k]에는 최대 무게가 k인 배낭에 n개의 물건을 넣었을 때 가지는 최대의 가치이다.
dp[n][k] = 최대 가치
배열에 대한 정리를 끝냈다면, 무게를 조정하는 조건을 확인하고 알고리즘을 튜닝하자. 

1. 배낭에 넣는 케이스
    - 현재 넣을 물건 무게를 더해도 배낭의 최대무게 k보다 작은 경우
    - 이미 등록되어있는 dp[n][k]보다, 기존 물건을 빼고 현재 물건을 넣었을 때 가치가 더 커지는 경우 
2. 배낭에 넣지않는 케이스
    - 기존 물건을 빼고 현재 물건을 넣었을 때 최대 가치가 바뀌지 않는 경우
    - 현재 넣을 물건 무게가 배낭의 최대무게 k보다 커지는 경우

'''
import sys
input = sys.stdin.readline

n, k = map(int, input().split())
bag = [(0,0)]
for _ in range(n):
  bag.append(tuple(map(int, input().split()))) # (w,v) 형태로 가방별 무게와 가치를 받음
dp = [[0] * (k+1) for _ in range(n+1)]

for i in range(1, n+1):
  for j in range(1, k+1): # 넣을 수 있는 배낭 무게
    w = bag[i][0] 
    v = bag[i][1]
    if j < w: # 현재 가방 최대무게가 물건의 무게보다 작을 때 
      dp[i][j] = dp[i-1][j] # 물건을 넣지 않는다. 최대 가치를 그대로 기록한다.
    else : # j >= w
      dp[i][j] = max(dp[i-1][j], dp[i-1][j-w] + v)
      # 물건을 적게 넣고 최대무게는 지금과 같은 케이스의 가치가 높은지, 
      # 물건을 빼고 지금 물건을 넣은 현재 가치가 높은지 확인하여 저장

print(dp[n][k])